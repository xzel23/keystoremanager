name: Build (Windows, Linux, macOS ARM) and Release Installers

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build:
    name: Build and Package (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            installerType: deb
            artifactSuffix: linux
          - os: windows-latest
            installerType: exe
            artifactSuffix: windows
          - os: macos-14
            installerType: dmg
            artifactSuffix: macos-arm

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Liberica JDK 25 (with JavaFX)
        uses: actions/setup-java@v4
        with:
          distribution: liberica
          java-version: '25'
          java-package: jdk+fx

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Show Java/Gradle versions
        run: |
          java -version
          ./gradlew --version

      - name: Build
        run: ./gradlew --no-daemon --stacktrace build

      # ---------- Platform-specific signing preparation ----------
      - name: Prepare macOS code signing (keychain)
        if: matrix.os == 'macos-14' && secrets.MAC_SIGN_CERT_P12 != '' && secrets.MAC_SIGN_CERT_PASSWORD != '' && secrets.MAC_SIGN_IDENTITY != ''
        shell: bash
        env:
          P12_B64: ${{ secrets.MAC_SIGN_CERT_P12 }}
          P12_PASS: ${{ secrets.MAC_SIGN_CERT_PASSWORD }}
          MAC_SIGN_IDENTITY: ${{ secrets.MAC_SIGN_IDENTITY }}
        run: |
          set -euo pipefail
          echo "Preparing temporary keychain for macOS signing"
          KEYCHAIN="$RUNNER_TEMP/build.keychain-db"
          echo "$P12_B64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
          security create-keychain -p "github-actions" "$KEYCHAIN"
          security set-keychain-settings "$KEYCHAIN"
          security unlock-keychain -p "github-actions" "$KEYCHAIN"
          security import "$RUNNER_TEMP/cert.p12" -k "$KEYCHAIN" -P "$P12_PASS" -T /usr/bin/codesign -T /usr/bin/security || true
          security list-keychains -d user -s "$KEYCHAIN"
          security set-key-partition-list -S apple-tool:,apple: -s -k "github-actions" "$KEYCHAIN" || true
          echo "KEYCHAIN=$KEYCHAIN" >> "$GITHUB_ENV"
          echo "MAC_SIGN_IDENTITY=$MAC_SIGN_IDENTITY" >> "$GITHUB_ENV"
          echo "SIGNING_ARGS=-Pmac.sign=true -Pmac.identity=$MAC_SIGN_IDENTITY -Pmac.keychain=$KEYCHAIN" >> "$GITHUB_ENV"

      - name: Prepare Windows code signing (PFX)
        if: matrix.os == 'windows-latest' && secrets.WIN_CERT_PFX != '' && secrets.WIN_CERT_PASSWORD != '' && secrets.WIN_CERT_ALIAS != ''
        shell: bash
        env:
          PFX_B64: ${{ secrets.WIN_CERT_PFX }}
          PFX_PASS: ${{ secrets.WIN_CERT_PASSWORD }}
          PFX_ALIAS: ${{ secrets.WIN_CERT_ALIAS }}
        run: |
          set -euo pipefail
          KS="$RUNNER_TEMP/win-signing.pfx"
          echo "$PFX_B64" | base64 --decode > "$KS"
          # Common timestamp server
          TS_OPTS="/tr http://timestamp.digicert.com /td sha256 /fd sha256"
          echo "SIGNING_ARGS=-Pwin.sign=true -Pwin.keystore=$KS -Pwin.storepass=$PFX_PASS -Pwin.alias=$PFX_ALIAS -Pwin.signingOptions=$TS_OPTS" >> "$GITHUB_ENV"

      - name: Prepare Linux package signing (GPG for .deb)
        if: matrix.os == 'ubuntu-latest' && secrets.LINUX_GPG_PRIVATE_KEY != '' && secrets.LINUX_GPG_PASSPHRASE != '' && secrets.LINUX_GPG_KEY_ID != ''
        shell: bash
        env:
          GPG_KEY_B64: ${{ secrets.LINUX_GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.LINUX_GPG_PASSPHRASE }}
          GPG_KEY_ID: ${{ secrets.LINUX_GPG_KEY_ID }}
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y dpkg-sig
          echo "$GPG_KEY_B64" | base64 --decode > "$RUNNER_TEMP/gpg.key.asc"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --import "$RUNNER_TEMP/gpg.key.asc"
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> "$GITHUB_ENV"
          echo "GPG_PASSPHRASE=$GPG_PASSPHRASE" >> "$GITHUB_ENV"

      # ---------- Create installer with jpackage (with optional signing args) ----------
      - name: Create installer with jpackage
        env:
          SIGNING_ARGS: ${{ env.SIGNING_ARGS }}
        run: |
          echo "Using SIGNING_ARGS='${SIGNING_ARGS}'"
          ./gradlew --no-daemon --stacktrace jpackage -PinstallerType=${{ matrix.installerType }} ${SIGNING_ARGS:-}

      # ---------- Notarize and staple macOS DMG (optional) ----------
      - name: Notarize and staple DMG
        if: matrix.os == 'macos-14' && (secrets.APPLE_API_KEY != '' && secrets.APPLE_API_KEY_ID != '' && secrets.APPLE_API_ISSUER_ID != '')
        shell: bash
        env:
          APPLE_API_KEY_B64: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
        run: |
          set -euo pipefail
          echo "$APPLE_API_KEY_B64" | base64 --decode > "$RUNNER_TEMP/AuthKey.p8"
          DMG=(build/jpackage/*.dmg)
          if [ -e "${DMG[0]}" ]; then
            xcrun notarytool submit "${DMG[0]}" --key "$RUNNER_TEMP/AuthKey.p8" --key-id "$APPLE_API_KEY_ID" --issuer "$APPLE_API_ISSUER_ID" --wait
            xcrun stapler staple "${DMG[0]}"
          else
            echo "No DMG found to notarize"
          fi

      # ---------- Sign Linux .deb after build (optional) ----------
      - name: Sign .deb with GPG
        if: matrix.os == 'ubuntu-latest' && env.GPG_KEY_ID != ''
        shell: bash
        run: |
          set -euo pipefail
          for DEB in build/jpackage/*.deb; do
            [ -e "$DEB" ] || continue
            echo "Signing $DEB"
            dpkg-sig --sign builder -k "$GPG_KEY_ID" --gpg-options "--batch --yes --pinentry-mode loopback --passphrase $GPG_PASSPHRASE" "$DEB"
          done

      - name: Collect installer artifacts
        id: collect
        shell: bash
        run: |
          mkdir -p artifacts
          shopt -s nullglob
          # Look for common installer extensions in build/jpackage
          for f in build/jpackage/*.{dmg,pkg,msi,exe,deb,rpm}; do
            [ -e "$f" ] || continue
            cp -v "$f" artifacts/
          done
          echo "COUNT=$(ls -1 artifacts | wc -l | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Upload installer artifacts
        if: steps.collect.outputs.COUNT != '0'
        uses: actions/upload-artifact@v4
        with:
          name: keystoremanager-installers-${{ matrix.artifactSuffix }}
          path: artifacts/*
          if-no-files-found: error

  release:
    name: Create GitHub Release with Installers
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Download all installer artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Display downloaded files
        run: |
          ls -R release-artifacts || true

      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release-artifacts/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
